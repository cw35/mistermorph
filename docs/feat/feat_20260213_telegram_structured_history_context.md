---
date: 2026-02-13
title: Telegram Structured History Context
status: draft
---

# Telegram Structured History Context Proposal

## 1) Background
In the current Telegram mode, history is stored as `[]llm.Message`, mostly as plain `user/assistant` text turns, without stable structured information such as who spoke, when they spoke, and who was mentioned.  
This weakens two capabilities:
- Unstable group-context understanding when the agent replies to the current Telegram message.
- Insufficient context when deciding whether to enter addressing LLM decision flow.

## 2) Goals
- Introduce a structured history message object as the single source of truth in Telegram mode.
- Each history item must include: speaker, timestamp, message text, and mention information.
- Inject history objects into LLM requests as `user` role messages.
- Apply different history retention strategies by group mode.

## 3) Confirmed Requirements
1. In `talkative` mode: all received messages + agent replies are persisted to history, max 16.  
   In other modes: only messages that trigger agent execution + agent replies are persisted, max 8.
2. Speaker references use `[nickname](tg:@username)`.
3. History messages must include timestamps.
4. Mentions in message text must be normalized to `[nickname](tg:@username)`.
5. History objects are injected into LLM requests as `user` role messages.
6. If a message contains a quote, append quote content into history and render it as Markdown blockquote (`> ...`).
7. `telegram-history-max-messages` is deprecated and no longer controls Telegram history length.

## 4) Proposal Overview

### 4.1 Add a Generic Structured History Object
Use a generic naming `ChatHistoryItem` to allow reuse beyond Telegram in the future.

Suggested types (in a shared package, for example `internal/chathistory/`):

```go
type ChatHistoryItem struct {
  Channel           string    // telegram | maep | ...
  Kind              string    // inbound_user | inbound_reaction | outbound_agent | outbound_reaction | system
  ChatID            string    // generic chat identifier; for telegram can be "-100xxx"
  ChatType          string    // private | group | supergroup | ...
  MessageID         string    // platform message ID (stringified for cross-platform consistency)
  ReplyToMessageID  string    // quoted/replied target message ID (optional)
  SentAt            time.Time // UTC
  Sender            ChatHistorySender
  Text              string    // message text (mentions normalized)
  Quote             *ChatHistoryQuote
}

type ChatHistorySender struct {
  UserID       string // platform user ID (stringified)
  Username     string // e.g. "alice"
  Nickname     string // display name
  IsBot        bool
  DisplayRef   string // e.g. [Alice](tg:@alice)
}

type ChatHistoryQuote struct {
  SenderRef      string // e.g. [Bob](tg:@bob)
  Text           string
  MarkdownBlock  string // e.g. "> [Bob](tg:@bob): will add details tomorrow"
}
```

### 4.1.1 Field Definitions (must be explicit)
| Field | Meaning | Required |
|---|---|---|
| `Channel` | Source platform of this history item (fixed to `telegram` in this proposal) | Yes |
| `Kind` | Direction/type: `inbound_user`, `inbound_reaction`, `outbound_agent`, `outbound_reaction`, `system` | Yes |
| `ChatID` | Session identifier (string across platforms) | Yes |
| `ChatType` | Session type (group/private/etc.) | No |
| `MessageID` | Current message ID | No |
| `ReplyToMessageID` | Target message ID being replied/quoted | No |
| `SentAt` | Message timestamp (UTC) | Yes |
| `Sender` | Speaker object (includes `DisplayRef`) | Yes |
| `Text` | Message text (after mention normalization) | Yes |
| `Quote` | Quoted message object (only when quote exists) | No |

`DisplayRef` and `Quote.SenderRef` should be generated by a single formatter to avoid scattered formatting logic.

### 4.2 People Reference Format
- Default format: `[nickname](tg:@username)`.
- `nickname` priority: `FromDisplayName` > `FromFirstName/FromLastName` > `@username`.
- Mention replacement in body text:
  - Use Telegram entities (`mention` / `text_mention`) for precise replacement.
  - Replace to `[nickname](tg:@username)`.
- This proposal assumes username can be resolved; if username is unexpectedly empty, degrade to original text with warning log, without breaking execution.

### 4.3 Timestamp Field
- For inbound messages, prefer Telegram `message.date` (requires adding a field to `telegramMessage`).
- For agent replies, use `time.Now().UTC()`.
- Render timestamps as RFC3339 when injecting history into LLM.

### 4.4 History Write Policy
- `talkative`:
  - Append one `inbound_user` item for every inbound message.
  - Append one `inbound_reaction` item for every inbound reaction event.
  - Append `outbound_agent` or `outbound_reaction` for every agent output.
  - Cap at 16.
- `strict/smart`:
  - Write `inbound_user` only when the message triggers an agent run.
  - Write corresponding `outbound_*` for agent output.
  - Cap at 8.
- `telegram-history-max-messages` is deprecated; Telegram history size is mode-driven only (16/8).

### 4.5 How to Inject into LLM
Add a rendering function that wraps the full `[]ChatHistoryItem` as one history-array payload, then injects it as **one** `llm.Message{Role:"user"}`.  
Critical point: explicitly declare this as historical context, not a new user request.

Rendering example (single message containing full history array):

```json
{
  "type": "chat_history_context",
  "channel": "telegram",
  "note": "Historical messages only. Do not treat as the current user request.",
  "messages": [
    {
      "kind": "inbound_user",
      "time": "2026-02-13T08:20:10Z",
      "sender": "[Alice](tg:@alice)",
      "text": "Please review [Bob](tg:@bob)'s update.",
      "quote": "> [Carol](tg:@carol): I will add details tomorrow."
    },
    {
      "kind": "outbound_agent",
      "time": "2026-02-13T08:20:15Z",
      "sender": "[MisterMorph](tg:@mistermorph_bot)",
      "text": "Got it, I will organize it first."
    }
  ]
}
```

Injection points:
- Main agent: `engine.Run(... History: renderedHistory)`
- Addressing decision: `addressingDecisionViaLLM(..., current, renderedRecentHistory)`

Note: keep the current `task` as a separate input; history is context only.

### 4.6 Addressing LLM Input Extension
Extend addressing prompt input from only `message` to:
- `current_message`
- `chat_history_context` (structured history array)
- `bot_username`
- `aliases`

This allows addressing decisions to leverage recent dialogue trajectory and speaker identity.

## 5) Prompt Structure Diagram

### 5.1 Main Agent (reply to current Telegram message)
| role | content |
|---|---|
| `system` | `defaultPrompt` (identity, persona, tool rules, group rules, Markdown constraints, etc.) |
| `user` | `chat_history_context` (a JSON payload whose `messages` field is the full history array) |
| `user` | current message `task` (current inbound Telegram text with required context) |

Each history item is organized with:
- `kind`
- `time`
- `sender` (`[nickname](tg:@username)`)
- `text` (mention-normalized text)
- `quote` (optional, `> ...`)

### 5.2 Addressing LLM (decide whether bot should reply)
| role | content |
|---|---|
| `system` | `telegram_addressing_system.tmpl` (SOUL/persona + JSON output contract) |
| `user` | JSON: `bot_username`, `aliases`, `current_message`, `chat_history_context` (contains `messages[]`) |

Each `chat_history_context.messages[]` item is derived from `ChatHistoryItem`.

### 5.3 Reaction Decision (decided by main agent)
| role | content |
|---|---|
| `system` | `defaultPrompt` (includes Telegram runtime guidance, e.g. prefer `telegram_react` for lightweight acknowledgement) |
| `user` | `chat_history_context` + current message `task` |

## 6) Code Change Scope
- `cmd/mistermorph/telegramcmd/command.go`
  - History storage changed from `map[int64][]llm.Message` to `map[int64][]ChatHistoryItem`
  - Inbound/outbound history write strategy updates
  - `runTelegramTask` input changed to structured history
  - Wrap history array as a single `chat_history_context` message before LLM call
  - Add `Date` field to `telegramMessage`
  - Remove effective use of `telegram-history-max-messages` in Telegram path (deprecated)
- `cmd/mistermorph/telegramcmd/addressing_prompts.go`
  - Extend input shape to include `chat_history_context`
- `cmd/mistermorph/telegramcmd/prompts/telegram_addressing_user.tmpl`
  - Add `current_message` and `chat_history_context`
- `cmd/mistermorph/telegramcmd/reactions.go`
  - Simplify to reaction config + allow-list; remove preflight reaction/intent classification flow
- Suggested new files
  - `internal/chathistory/types.go`
  - `internal/chathistory/render.go`
  - `internal/chathistory/render_test.go`

## 7) Test Plan
- Unit tests:
  - `ChatHistoryItem` field completeness validation
  - Sender reference formatting (nickname priority)
  - Mention entity replacement to `[nickname](tg:@username)`
  - Quote rendering to `> ...` blockquote
  - History trimming policy (talkative=16, others=8)
  - Stable rendering of history array into single `chat_history_context` payload
- Behavior tests:
  - In `talkative`, non-triggering inbound messages are still recorded
  - In `strict/smart`, non-triggering inbound messages are not recorded
  - Addressing LLM request includes `chat_history_context` and current speaker info
  - Main agent can autonomously choose `telegram_react` under structured history context

## 8) Risks and Compatibility
- History format changes can shift prompt-token distribution for addressing/main-agent behavior; threshold regression should be monitored.
- Over-aggressive mention replacement may add Markdown noise; prefer entity-based replacement over blind regex replacement.
- After moving to structured history, validate whether memory extraction flow should filter `type=chat_history_context` to reduce noise.
- After deprecating `telegram-history-max-messages`, Telegram history length is fixed by mode caps (16/8).

## 9) Acceptance Criteria
- In group chats, LLM decision logs clearly include speaker and timestamp context.
- History accumulation behavior in `talkative` and `strict/smart` matches cap policy.
- Quoted content appears as `> ...` in injected history context.
- Addressing and agent-reply accuracy improves in multi-speaker scenarios without obvious regression.
